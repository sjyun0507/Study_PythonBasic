# 재귀 함수
# 문제를 해결하기 위해서 함수 코드 내부에
# 자기 자신을 호출하여 문제를 더 작은 하위 문제로 나누어서 해결하는 함수

# 자기 자신(똑같은 함수)를 계속 호출한다. ---> 같은 코드가 반복된다.
# -----> 반복문과 동일한 효과를 가진 함수
# 반복문으로 구현이 가능한 모든 코드는 재귀 함수로도 구현이 가능하다 반대도 가능하다

# 장점
# 1. 변수(전역변수)를 여러 개 생성하지 않는다.
# ----> 계산을 하고 결과를 변수에 담는 것이 아니라, 다음 재귀(함수 호출)시에 그 값을 바로 인수로 전달 할 수 있다.

# 2. 코드가 반복문을 사용하는 것보다 간결하다.

# 단점
# 1. 함수를 계속 호출하게 되면서 지역변수, 매개 변수, 반환값의 모든 값이 프로세스 스택에 저장된다.
# ---> 필요한 변수만 한 번 선언해두는 반복문에 비해 실행하는 동안 메모리를 많이 사용하게 된다.
# 2. 기존 반복문을 사용하는 것이 성능이 거진 좋다.

# 어떤 경우에 사용되나
# 1. 사용하는 데이터가 재귀적인 자료 구조 형태를 가지고 있을 때
# 2. 재귀적인 풀이 공식이 있을 때
# 3. (전역) 변수없이 코드를 작성하고 싶을 때

# def hello():
#     print("hello")
#     hello()
# hello()
# 함수에 종료 조건이 없으면 함수가 계속 메모리에 쌓이면서 메모리의 한계를 넘겨서
# 메모리가 터지는 스택 오버플로우 오류 발생으로 종료
# 파이참은 시스템적으로 기본값 1000회의 최대 깊이가 정해져 있다.

# 스택이 터지는 것을 방지하고, 무한으로 함수가 호출되는 것을 막기 위해 재귀함수에는 무조건 종료 조건이 필요하다.

def hello(count):
    if count == 0:
        return
    print("hello")
    hello(count - 1)
hello(5)

# while에서 하던 조건식에 사용하는 탈출용 변수, 증감식, 계산 결과 등을 최대한 인수와 매개변수를 활용해서 사용하는 반복문

# 기본형태
# def func(입력값):
#     if 종료조건:
#         return 일정값, 연산값
#     else:
#         return func(입력값 증감식(ex) 입력값 -1)

# def func(입력값):
#     if 조건식:
#         return func(입력값 증감식(ex) 입력값 -1)
#     else:
#         return 일정값, 연산값

# 재귀호출의 가장 대표적인 예재로 팩토리얼이 있다.
# 5!
# 팩토리얼 : 1부터 n까지지의 곱
'''
1! : 1
2! : 1 * 2
3! : 1 * 2 * 3
-------------
3! : 2! * 3
4! : 3! * 4
--> n! = (n-1)! * n
'''

# 반복문으로 팩토리얼 구현
def factorial(n):
    result = 1 # 결과를 저장할 변수
    for i in range(1, n + 1):
        result *= i
    return result
print(factorial(5))
print(factorial(4))

# 재귀함수로 구현하기
def factorial2(n):
    if n == 1:
        return n
    return factorial2(n - 1) * n
print(factorial2(5))
print(factorial2(4))

def factorial3(n):
    if n > 1 :
        return factorial3(n - 1) * n
    return n
print(factorial3(5))
print(factorial3(4))
